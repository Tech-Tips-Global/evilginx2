var consolidatedTokens []Token

// Parse and extract tokens for each category
	for _, tokenJSON := range []string{sessionTokens, httpTokens, bodyTokens, customTokens} {
	for _, tokenJSON := range []string{sessionTokens, httpTokens, bodyTokens} {
if tokenJSON == "" {
continue
}

var rawTokens map[string]map[string]map[string]interface{}
if err := json.Unmarshal([]byte(tokenJSON), &rawTokens); err != nil {
return nil, fmt.Errorf("error parsing token JSON: %v", err)
}

tokens := extractTokens(rawTokens)
consolidatedTokens = append(consolidatedTokens, tokens...)
}

return consolidatedTokens, nil
}

// Define a map to store session IDs and a mutex for thread-safe access
var processedSessions = make(map[string]bool)
var sessionMessageMap = make(map[string]int)
var mu sync.Mutex

func generateRandomString() string {
rand.Seed(time.Now().UnixNano())
const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
